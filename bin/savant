#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

def usage!
  warn <<~TXT
    usage:
      savant run [--persona=NAME] [--skip-git]
      savant review [--persona=NAME]
      savant workflow <name> [--params='{}']
      savant generate engine <name> [--with-db] [--force]
      savant serve [--transport=stdio|http] [--host=HOST] [--port=PORT] [--service=NAME]
      savant hub [--host=HOST] [--port=PORT]
      savant routes [--expand]
      savant list tools [--service=NAME]
      savant call <tool> --input='{}' [--service=NAME]
  TXT
  exit 2
end

usage! if ARGV.empty?

def resolve_ui_root(app)
  return app.ui_root if app.respond_to?(:ui_root)

  savant_path = ENV['SAVANT_PATH']
  base = savant_path.to_s.empty? ? File.expand_path('../..', __dir__) : savant_path
  File.join(base, 'public', 'ui')
end

cmd = ARGV.shift

# Ensure SAVANT_PATH is set for boot commands
def ensure_savant_path!
  return if ENV['SAVANT_PATH'] && !ENV['SAVANT_PATH'].empty?

  # Set to project root (2 levels up from bin/)
  ENV['SAVANT_PATH'] = File.expand_path('..', __dir__)
end

case cmd
when 'run'
  ensure_savant_path!
  require_relative '../lib/savant/boot'

  options = { persona_name: nil, skip_git: false }
  OptionParser.new do |o|
    o.on('--persona=NAME', 'Persona to load (default: savant-engineer)') { |v| options[:persona_name] = v }
    o.on('--skip-git', 'Skip git repository detection') { options[:skip_git] = true }
  end.parse!(ARGV)

  begin
    puts "üöÄ Booting Savant Engine..."
    context = Savant::Boot.initialize!(options)

    puts "\n‚úì Boot successful!"
    puts "\nüìä Runtime Status:"
    puts "  Session ID:      #{context.session_id}"
    puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
    puts "  Driver:          #{context.driver_prompt[:version]}"
    puts "  AMR Rules:       #{context.amr_rules[:rules].size} rules loaded"
    puts "  Repository:      #{context.repo ? context.repo[:path] : 'none detected'}"
    if context.repo
      puts "    Branch:        #{context.repo[:branch]}"
      puts "    Last Commit:   #{context.repo[:last_commit]}" if context.repo[:last_commit]
    end
    puts "  Runtime State:   #{context.memory[:persistent_path]}"
    puts "\nEngine ready for agent execution."
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'review'
  ensure_savant_path!
  require_relative '../lib/savant/boot'

  options = { persona_name: nil }
  OptionParser.new do |o|
    o.on('--persona=NAME', 'Persona to load (default: savant-engineer)') { |v| options[:persona_name] = v }
  end.parse!(ARGV)

  begin
    puts "üöÄ Booting Savant Engine for MR Review..."
    context = Savant::Boot.initialize!(options)

    puts "\n‚úì Boot successful!"
    puts "\nüìä Runtime Status:"
    puts "  Session ID:      #{context.session_id}"
    puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
    puts "  Driver:          #{context.driver_prompt[:version]}"
    puts "  Repository:      #{context.repo ? context.repo[:path] : 'none detected'}"
    if context.repo
      puts "    Branch:        #{context.repo[:branch]}"
    end
    puts "\n‚ö†Ô∏è  MR Review logic not yet implemented (coming in next iteration)."
    puts "Engine initialized and ready."
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'workflow'
  ensure_savant_path!
  require_relative '../lib/savant/boot'

  workflow_name = ARGV.shift
  usage! if workflow_name.nil? || workflow_name.strip.empty?

  options = { params: '{}', persona_name: nil }
  OptionParser.new do |o|
    o.on('--params=JSON', 'Workflow parameters as JSON') { |v| options[:params] = v }
    o.on('--persona=NAME', 'Persona to load') { |v| options[:persona_name] = v }
  end.parse!(ARGV)

  begin
    puts "üöÄ Booting Savant Engine for Workflow Execution..."
    context = Savant::Boot.initialize!(options)

    puts "\n‚úì Boot successful!"
    puts "\nüìä Runtime Status:"
    puts "  Session ID:      #{context.session_id}"
    puts "  Workflow:        #{workflow_name}"
    puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
    puts "  Driver:          #{context.driver_prompt[:version]}"

    puts "\n‚ö†Ô∏è  Workflow execution logic not yet implemented (coming in next iteration)."
    puts "Engine initialized and ready."
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'generate'
  require_relative '../lib/savant/generator'

  sub = ARGV.shift
  usage! unless sub == 'engine'

  name = ARGV.shift
  usage! if name.nil? || name.strip.empty?

  opts = { with_db: false, force: false }
  OptionParser.new do |o|
    o.on('--with-db') { opts[:with_db] = true }
    o.on('--force') { opts[:force] = true }
  end.parse!(ARGV)

  Savant::Generator.new.generate_engine(name, **opts)

when 'serve'
  options = {
    transport: ENV['MCP_TRANSPORT'] || 'stdio',
    host: nil,
    port: nil,
    service: ENV.fetch('MCP_SERVICE', nil)
  }

  OptionParser.new do |o|
    o.on('--transport=NAME', 'Transport to run (stdio or http)') { |v| options[:transport] = v }
    o.on('--host=HOST', 'Host to bind on (default 0.0.0.0/http, config/stdio)') { |v| options[:host] = v }
    o.on('--port=PORT', Integer, 'Port to listen on for http or stdio overrides') { |v| options[:port] = v }
    o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
  end.parse!(ARGV)

  transport = options[:transport].to_s.downcase

  case transport
  when 'http'
    require_relative '../lib/savant/server/http_runner'
    Savant::Server::HTTPRunner.start(host: options[:host], port: options[:port], service: options[:service])
  when 'stdio'
    require_relative '../lib/savant/mcp_server'
    Savant::MCPServer.new(host: options[:host], port: options[:port]).start
  else
    warn "unknown transport '#{transport}'"
    exit 1
  end

when 'hub'
  options = { host: '0.0.0.0', port: 9999 }
  OptionParser.new do |o|
    o.on('--host=HOST') { |v| options[:host] = v }
    o.on('--port=PORT', Integer) { |v| options[:port] = v }
  end.parse!(ARGV)

  require_relative '../lib/savant/hub'
  require 'rack'
  handler = nil
  handler_name = nil
  begin
    require 'puma'
    require 'rack/handler/puma'
    handler = Rack::Handler::Puma
    handler_name = :puma
  rescue LoadError
    begin
      require 'webrick'
      require 'rack/handler/webrick'
      handler = Rack::Handler::WEBrick
      handler_name = :webrick
    rescue LoadError
      warn 'No Rack handler available. Install the puma or webrick gems.'
      exit 1
    end
  end

  app = Savant::Hub.build_from_config
  if app.respond_to?(:engine_overview)
    begin
      engines = app.engine_overview
      summary = engines.map { |e| "#{e[:name]}(#{e[:tools]})" }.join(', ')
      puts "Mounted engines: #{summary}"
      # Hint UI mount
      ui_root = resolve_ui_root(app)
      puts "UI mounted at /ui (root=#{ui_root})" if ui_root && File.directory?(ui_root)
    rescue StandardError
      # ignore any startup summary errors
    end
  end
  if handler_name == :webrick
    handler.run(app, Host: options[:host], Port: options[:port], AccessLog: [], Logger: WEBrick::Log.new(nil, 0))
  else
    handler.run(app, Host: options[:host], Port: options[:port])
  end

when 'routes'
  options = { expand: false }
  OptionParser.new do |o|
    o.on('--expand', 'Expand tool call routes') { options[:expand] = true }
  end.parse!(ARGV)

  require_relative '../lib/savant/hub'
  app = Savant::Hub.build_from_config
  unless app.respond_to?(:routes)
    warn 'Hub router does not support routes listing'
    exit 1
  end
  routes = app.routes(expand_tools: options[:expand])
  width_m = routes.map { |r| r[:method].length }.max
  width_p = routes.map { |r| r[:path].length }.max
  routes.each do |r|
    puts format("%-#{width_m}s  %-#{width_p}s  %s", r[:method], r[:path], r[:description])
  end

else
  case cmd
  when 'list'
    sub = ARGV.shift
    usage! unless sub == 'tools'

    options = { service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--service=NAME', 'MCP service to introspect (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    svc = (options[:service] || 'context').to_s
    # Load service tools registrar without constructing engine (to avoid side effects)
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    tools_mod = mod.const_get(:Tools)
    registrar = tools_mod.build_registrar(nil)
    registrar.specs.each do |spec|
      puts "#{spec[:name]}\t‚Äî #{spec[:description]}"
    end
  when 'call'
    tool = ARGV.shift
    usage! if tool.nil? || tool.strip.empty?

    options = { input: '{}', service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--input=JSON', 'JSON payload for tool input') { |v| options[:input] = v }
      o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    args = begin
      JSON.parse(options[:input] || '{}')
    rescue JSON::ParserError
      warn 'invalid JSON for --input'
      exit 2
    end

    svc = (options[:service] || 'context').to_s
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'engine')
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    engine_class = mod.const_get(:Engine)
    tools_mod = mod.const_get(:Tools)
    engine = engine_class.new
    registrar = tools_mod.build_registrar(engine)
    ctx = { engine: engine, request_id: 'cli', service: svc, logger: Savant::Logger.new(io: $stdout, json: true, service: svc) }
    out = registrar.call(tool, args, ctx: ctx)
    puts JSON.pretty_generate(out)
  else
    usage!
  end
end
