#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

def usage!
  warn <<~TXT
    usage:
      savant run [--persona=NAME] [--skip-git] [--agent-input=TEXT|--agent-file=PATH] [--slm=MODEL] [--llm=MODEL] [--max-steps=N] [--dry-run]
      savant review [--persona=NAME]
      savant workflow <name> [--params='{}']
      savant generate engine <name> [--with-db] [--force]
      savant serve [--transport=stdio|http] [--host=HOST] [--port=PORT] [--service=NAME]
      savant hub [--host=HOST] [--port=PORT]
      savant routes [--expand]
      savant list tools [--service=NAME]
      savant call <tool> --input='{}' [--service=NAME]
  TXT
  exit 2
end

usage! if ARGV.empty?

def resolve_ui_root(app)
  return app.ui_root if app.respond_to?(:ui_root)

  savant_path = ENV['SAVANT_PATH']
  base = savant_path.to_s.empty? ? File.expand_path('../..', __dir__) : savant_path
  File.join(base, 'public', 'ui')
end

cmd = ARGV.shift

# Ensure SAVANT_PATH is set for boot commands
def ensure_savant_path!
  return if ENV['SAVANT_PATH'] && !ENV['SAVANT_PATH'].empty?

  # Set to project root (2 levels up from bin/)
  ENV['SAVANT_PATH'] = File.expand_path('..', __dir__)
end

case cmd
when 'run'
  ensure_savant_path!
  require_relative '../lib/savant/framework/boot'
  require_relative '../lib/savant/agent/runtime'
  require 'json'

  options = { persona_name: nil, skip_git: false, agent_input: nil, agent_file: nil, slm: nil, llm: nil, max_steps: nil, dry_run: false, quiet: false, force_tool: nil, force_args: '{}', force_finish: false, force_final: nil, force_finish_only: false }
  OptionParser.new do |o|
    o.on('--persona=NAME', 'Persona to load (default: savant-engineer)') { |v| options[:persona_name] = v }
    o.on('--skip-git', 'Skip git repository detection') { options[:skip_git] = true }
    o.on('--agent-input=TEXT', 'Run agent with input goal text') { |v| options[:agent_input] = v }
    o.on('--agent-file=PATH', 'Run agent with input goal file') { |v| options[:agent_file] = v }
    o.on('--slm=MODEL', 'Override SLM model') { |v| options[:slm] = v }
    o.on('--llm=MODEL', 'Override LLM model') { |v| options[:llm] = v }
    o.on('--max-steps=N', Integer, 'Max reasoning steps') { |v| options[:max_steps] = v }
    o.on('--dry-run', 'Plan and simulate tool calls only') { options[:dry_run] = true }
    o.on('--quiet', 'Reduce console logs (errors only, no JSON logs)') { options[:quiet] = true }
    o.on('--force-tool=NAME', 'Force a first-step tool call (fully qualified name)') { |v| options[:force_tool] = v }
    o.on('--force-args=JSON', 'JSON object for forced tool args') { |v| options[:force_args] = v }
    o.on('--force-finish', 'Immediately finish after forced tool, or finish at step 1 if no forced tool') { options[:force_finish] = true }
    o.on('--force-final=TEXT', 'Final text for forced finish') { |v| options[:force_final] = v }
    o.on('--force-finish-only', 'Finish immediately without executing any tool (ignores --force-tool)') { options[:force_finish_only] = true }
    # Alias to accommodate common shorthand/typo
    o.on('--force-finish-onl') { options[:force_finish_only] = true }
  end.parse!(ARGV)

  begin
    ENV['SAVANT_QUIET'] = '1' if options[:quiet]
    ENV['LOG_LEVEL'] ||= 'error' if options[:quiet]

    puts 'üöÄ Booting Savant Engine...' unless options[:quiet]
    context = Savant::Boot.initialize!(options)

    unless options[:quiet]
      puts "\n‚úì Boot successful!"
      puts "\nüìä Runtime Status:"
      puts "  Session ID:      #{context.session_id}"
      puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
      puts "  Driver:          #{context.driver_prompt[:version]}"
      puts "  AMR Rules:       #{context.amr_rules[:rules].size} rules loaded"
      puts "  Repository:      #{context.repo ? context.repo[:path] : 'none detected'}"
      if context.repo
        puts "    Branch:        #{context.repo[:branch]}"
        puts "    Last Commit:   #{context.repo[:last_commit]}" if context.repo[:last_commit]
      end
      puts "  Runtime State:   #{context.memory[:persistent_path]}"
      puts "\nEngine ready for agent execution."
    end

    # If agent input provided, execute a session now
    goal = options[:agent_input]
    if !goal && options[:agent_file]
      begin
        goal = File.read(options[:agent_file]).to_s
      rescue StandardError => e
        warn "Failed to read agent input file: #{e.message}"
        exit 1
      end
    end

    if goal && !goal.strip.empty?
      puts "\nüß† Running agent session..." unless options[:quiet]
      force_args_hash = begin
        JSON.parse(options[:force_args] || '{}')
      rescue JSON::ParserError
        warn 'Invalid JSON for --force-args (falling back to {})'
        {}
      end
      # If --force-finish-only is set, override other force flags to ensure immediate finish without tools
      if options[:force_finish_only]
        options[:force_finish] = true
        options[:force_tool] = nil
      end
      agent = Savant::Agent::Runtime.new(goal: goal, slm_model: options[:slm], llm_model: options[:llm], forced_tool: options[:force_tool], forced_args: force_args_hash, forced_finish: options[:force_finish], forced_final: options[:force_final])
      res = agent.run(max_steps: options[:max_steps] || 25, dry_run: options[:dry_run])
      puts JSON.pretty_generate(res)
    end
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'review'
  ensure_savant_path!
  require_relative '../lib/savant/framework/boot'

  options = { persona_name: nil }
  OptionParser.new do |o|
    o.on('--persona=NAME', 'Persona to load (default: savant-engineer)') { |v| options[:persona_name] = v }
  end.parse!(ARGV)

  begin
    puts 'üöÄ Booting Savant Engine for MR Review...'
    context = Savant::Boot.initialize!(options)

    puts "\n‚úì Boot successful!"
    puts "\nüìä Runtime Status:"
    puts "  Session ID:      #{context.session_id}"
    puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
    puts "  Driver:          #{context.driver_prompt[:version]}"
    puts "  Repository:      #{context.repo ? context.repo[:path] : 'none detected'}"
    puts "    Branch:        #{context.repo[:branch]}" if context.repo
    puts "\n‚ö†Ô∏è  MR Review logic not yet implemented (coming in next iteration)."
    puts 'Engine initialized and ready.'
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'workflow'
  ensure_savant_path!
  require_relative '../lib/savant/framework/boot'
  require_relative '../lib/savant/engines/workflow/engine'

  workflow_name = ARGV.shift
  usage! if workflow_name.nil? || workflow_name.strip.empty?

  options = { params: '{}', persona_name: nil }
  OptionParser.new do |o|
    o.on('--params=JSON', 'Workflow parameters as JSON') { |v| options[:params] = v }
    o.on('--persona=NAME', 'Persona to load') { |v| options[:persona_name] = v }
  end.parse!(ARGV)

  begin
    puts 'üöÄ Booting Savant Engine for Workflow Execution...'
    context = Savant::Boot.initialize!(options)

    puts "\n‚úì Boot successful!"
    puts "\nüìä Runtime Status:"
    puts "  Session ID:      #{context.session_id}"
    puts "  Workflow:        #{workflow_name}"
    puts "  Persona:         #{context.persona[:name]} (v#{context.persona[:version]})"
    puts "  Driver:          #{context.driver_prompt[:version]}"
    params = begin
      JSON.parse(options[:params] || '{}')
    rescue JSON::ParserError
      warn 'Invalid JSON for --params (falling back to {})'
      {}
    end

    engine = Savant::Workflow::Engine.new(base_path: ENV['SAVANT_PATH'])
    puts "\n‚ñ∂Ô∏è  Running workflow..."
    res = engine.run(workflow: workflow_name, params: params)
    puts "\n‚úÖ Workflow finished (status=#{res[:status]} run_id=#{res[:run_id]})"
    puts JSON.pretty_generate(res)
  rescue Savant::Boot::BootError => e
    warn "\n‚ùå Boot failed: #{e.message}"
    exit 1
  end

when 'generate'
  require_relative '../lib/savant/generator'

  sub = ARGV.shift
  usage! unless sub == 'engine'

  name = ARGV.shift
  usage! if name.nil? || name.strip.empty?

  opts = { with_db: false, force: false }
  OptionParser.new do |o|
    o.on('--with-db') { opts[:with_db] = true }
    o.on('--force') { opts[:force] = true }
  end.parse!(ARGV)

  Savant::Generator.new.generate_engine(name, **opts)

when 'engines'
  ensure_savant_path!
  require 'json'
  require_relative '../lib/savant/multiplexer'

  options = { json: false }
  OptionParser.new do |o|
    o.on('--json', 'Output JSON instead of table') { options[:json] = true }
  end.parse!(ARGV)

  mux = Savant::Multiplexer.ensure!(base_path: ENV['SAVANT_PATH'])
  unless mux
    warn 'Multiplexer disabled (set SAVANT_MULTIPLEXER_DISABLED=0 to enable)'
    exit 1
  end
  engines = mux.engines
  if options[:json]
    puts JSON.pretty_generate(engines)
  else
    puts format('%-12s %-10s %-8s %-6s %-10s', 'Engine', 'Status', 'PID', 'Tools', 'Uptime')
    engines.each do |name, info|
      puts format('%-12s %-10s %-8s %-6d %-10d', name, info[:status], info[:pid] || '-', info[:tools].to_i, info[:uptime_seconds].to_i)
    end
  end

when 'tools'
  ensure_savant_path!
  require 'json'
  require_relative '../lib/savant/multiplexer'

  options = { json: false }
  OptionParser.new do |o|
    o.on('--json', 'Output JSON array') { options[:json] = true }
  end.parse!(ARGV)

  mux = Savant::Multiplexer.ensure!(base_path: ENV['SAVANT_PATH'])
  unless mux
    warn 'Multiplexer disabled (set SAVANT_MULTIPLEXER_DISABLED=0 to enable)'
    exit 1
  end
  tool_specs = mux.tools.sort_by { |spec| spec[:name] || spec['name'] }
  if options[:json]
    puts JSON.pretty_generate(tool_specs)
  else
    tool_specs.each do |spec|
      name = spec[:name] || spec['name']
      desc = spec[:description] || spec['description'] || ''
      puts format('%-50s %s', name, desc)
    end
    puts "Total tools: #{tool_specs.size}"
  end

when 'serve'
  options = {
    transport: ENV['MCP_TRANSPORT'] || 'stdio',
    host: nil,
    port: nil,
    service: ENV.fetch('MCP_SERVICE', nil)
  }

  OptionParser.new do |o|
    o.on('--transport=NAME', 'Transport to run (stdio or http)') { |v| options[:transport] = v }
    o.on('--host=HOST', 'Host to bind on (default 0.0.0.0/http, config/stdio)') { |v| options[:host] = v }
    o.on('--port=PORT', Integer, 'Port to listen on for http or stdio overrides') { |v| options[:port] = v }
    o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
  end.parse!(ARGV)

  transport = options[:transport].to_s.downcase

  case transport
  when 'http'
    require_relative '../lib/savant/server/http_runner'
    Savant::Server::HTTPRunner.start(host: options[:host], port: options[:port], service: options[:service])
  when 'stdio'
    require_relative '../lib/savant/mcp_server'
    Savant::MCPServer.new(host: options[:host], port: options[:port]).start
  else
    warn "unknown transport '#{transport}'"
    exit 1
  end

when 'hub'
  options = { host: '0.0.0.0', port: 9999 }
  OptionParser.new do |o|
    o.on('--host=HOST') { |v| options[:host] = v }
    o.on('--port=PORT', Integer) { |v| options[:port] = v }
  end.parse!(ARGV)

  require_relative '../lib/savant/hub/builder'
  require 'rack'
  handler = nil
  handler_name = nil
  begin
    require 'puma'
    require 'rack/handler/puma'
    handler = Rack::Handler::Puma
    handler_name = :puma
  rescue LoadError
    begin
      require 'webrick'
      require 'rack/handler/webrick'
      handler = Rack::Handler::WEBrick
      handler_name = :webrick
    rescue LoadError
      warn 'No Rack handler available. Install the puma or webrick gems.'
      exit 1
    end
  end

  app = Savant::Hub.build_from_config
  if app.respond_to?(:engine_overview)
    begin
      engines = app.engine_overview
      summary = engines.map { |e| "#{e[:name]}(#{e[:tools]})" }.join(', ')
      puts "Mounted engines: #{summary}"
      # Hint UI mount
      ui_root = resolve_ui_root(app)
      puts "UI mounted at /ui (root=#{ui_root})" if ui_root && File.directory?(ui_root)
    rescue StandardError
      # ignore any startup summary errors
    end
  end
  if handler_name == :webrick
    handler.run(app, Host: options[:host], Port: options[:port], AccessLog: [], Logger: WEBrick::Log.new(nil, 0))
  else
    handler.run(app, Host: options[:host], Port: options[:port])
  end

when 'routes'
  options = { expand: false }
  OptionParser.new do |o|
    o.on('--expand', 'Expand tool call routes') { options[:expand] = true }
  end.parse!(ARGV)

  require_relative '../lib/savant/hub/builder'
  app = Savant::Hub.build_from_config
  unless app.respond_to?(:routes)
    warn 'Hub router does not support routes listing'
    exit 1
  end
  routes = app.routes(expand_tools: options[:expand])
  width_m = routes.map { |r| r[:method].length }.max
  width_p = routes.map { |r| r[:path].length }.max
  routes.each do |r|
    puts format("%-#{width_m}s  %-#{width_p}s  %s", r[:method], r[:path], r[:description])
  end

else
  case cmd
  when 'list'
    sub = ARGV.shift
    usage! unless sub == 'tools'

    options = { service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--service=NAME', 'MCP service to introspect (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    svc = (options[:service] || 'context').to_s
    # Load service tools registrar without constructing engine (to avoid side effects)
    require File.join(__dir__, '..', 'lib', 'savant', 'engines', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    tools_mod = mod.const_get(:Tools)
    registrar = tools_mod.build_registrar(nil)
    registrar.specs.each do |spec|
      puts "#{spec[:name]}\t‚Äî #{spec[:description]}"
    end
  when 'call'
    tool = ARGV.shift
    usage! if tool.nil? || tool.strip.empty?

    options = { input: '{}', service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--input=JSON', 'JSON payload for tool input') { |v| options[:input] = v }
      o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    args = begin
      JSON.parse(options[:input] || '{}')
    rescue JSON::ParserError
      warn 'invalid JSON for --input'
      exit 2
    end

    svc = (options[:service] || 'context').to_s
    require File.join(__dir__, '..', 'lib', 'savant', 'engines', svc, 'engine')
    require File.join(__dir__, '..', 'lib', 'savant', 'engines', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    engine_class = mod.const_get(:Engine)
    tools_mod = mod.const_get(:Tools)
    engine = engine_class.new
    registrar = tools_mod.build_registrar(engine)
    ctx = { engine: engine, request_id: 'cli', service: svc, logger: Savant::Logger.new(io: $stdout, json: true, service: svc) }
    out = registrar.call(tool, args, ctx: ctx)
    puts JSON.pretty_generate(out)
  else
    usage!
  end
end
