#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

def usage!
  warn <<~TXT
    usage:
      savant generate engine <name> [--with-db] [--force]
      savant serve [--transport=stdio|http] [--host=HOST] [--port=PORT] [--service=NAME]
      savant hub [--host=HOST] [--port=PORT]
      savant list tools [--service=NAME]
      savant call <tool> --input='{}' [--service=NAME]
  TXT
  exit 2
end

cmd = ARGV.shift

case cmd
when 'generate'
  require_relative '../lib/savant/generator'

  sub = ARGV.shift
  usage! unless sub == 'engine'

  name = ARGV.shift
  usage! if name.nil? || name.strip.empty?

  opts = { with_db: false, force: false }
  OptionParser.new do |o|
    o.on('--with-db') { opts[:with_db] = true }
    o.on('--force') { opts[:force] = true }
  end.parse!(ARGV)

  Savant::Generator.new.generate_engine(name, **opts)

when 'serve'
  options = {
    transport: ENV['MCP_TRANSPORT'] || 'stdio',
    host: nil,
    port: nil,
    service: ENV.fetch('MCP_SERVICE', nil)
  }

  OptionParser.new do |o|
    o.on('--transport=NAME', 'Transport to run (stdio or http)') { |v| options[:transport] = v }
    o.on('--host=HOST', 'Host to bind on (default 0.0.0.0/http, config/stdio)') { |v| options[:host] = v }
    o.on('--port=PORT', Integer, 'Port to listen on for http or stdio overrides') { |v| options[:port] = v }
    o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
  end.parse!(ARGV)

  transport = options[:transport].to_s.downcase

  case transport
  when 'http'
    require_relative '../lib/savant/server/http_runner'
    Savant::Server::HTTPRunner.start(host: options[:host], port: options[:port], service: options[:service])
  when 'stdio'
    require_relative '../lib/savant/mcp_server'
    Savant::MCPServer.new(host: options[:host], port: options[:port]).start
  else
    warn "unknown transport '#{transport}'"
    exit 1
  end

when 'hub'
  options = { host: '0.0.0.0', port: 9999 }
  OptionParser.new do |o|
    o.on('--host=HOST') { |v| options[:host] = v }
    o.on('--port=PORT', Integer) { |v| options[:port] = v }
  end.parse!(ARGV)

  require_relative '../lib/savant/hub'
  require 'rack'
  handler = nil
  begin
    require 'puma'
    require 'rack/handler/puma'
    handler = Rack::Handler::Puma
  rescue LoadError
    begin
      require 'webrick'
      require 'rack/handler/webrick'
      handler = Rack::Handler::WEBrick
    rescue LoadError
      warn 'No Rack handler available. Install the puma or webrick gems.'
      exit 1
    end
  end

  app = Savant::Hub.build_from_config
  if handler == Rack::Handler::WEBrick
    handler.run(app, Host: options[:host], Port: options[:port], AccessLog: [], Logger: WEBrick::Log.new(nil, 0))
  else
    handler.run(app, Host: options[:host], Port: options[:port])
  end

else
  case cmd
  when 'list'
    sub = ARGV.shift
    usage! unless sub == 'tools'

    options = { service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--service=NAME', 'MCP service to introspect (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    svc = (options[:service] || 'context').to_s
    # Load service tools registrar without constructing engine (to avoid side effects)
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    tools_mod = mod.const_get(:Tools)
    registrar = tools_mod.build_registrar(nil)
    registrar.specs.each do |spec|
      puts "#{spec[:name]}\tâ€” #{spec[:description]}"
    end
  when 'call'
    tool = ARGV.shift
    usage! if tool.nil? || tool.strip.empty?

    options = { input: '{}', service: ENV['MCP_SERVICE'] }
    OptionParser.new do |o|
      o.on('--input=JSON', 'JSON payload for tool input') { |v| options[:input] = v }
      o.on('--service=NAME', 'MCP service to run (context, jira, etc.)') { |v| options[:service] = v }
    end.parse!(ARGV)

    args = begin
      JSON.parse(options[:input] || '{}')
    rescue JSON::ParserError
      warn 'invalid JSON for --input'
      exit 2
    end

    svc = (options[:service] || 'context').to_s
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'engine')
    require File.join(__dir__, '..', 'lib', 'savant', svc, 'tools')
    camel = svc.split(/[^a-zA-Z0-9]/).map { |s| s[0] ? s[0].upcase + s[1..] : '' }.join
    mod = Savant.const_get(camel)
    engine_class = mod.const_get(:Engine)
    tools_mod = mod.const_get(:Tools)
    engine = engine_class.new
    registrar = tools_mod.build_registrar(engine)
    ctx = { engine: engine, request_id: 'cli', service: svc, logger: Savant::Logger.new(io: $stdout, json: true, service: svc) }
    out = registrar.call(tool, args, ctx: ctx)
    puts JSON.pretty_generate(out)
  else
    usage!
  end
end
